a29  
modulos

lib math
import math

math.sqrt(36)//raiz 
math.sin(45) //seno
math.cos(45) // coseno
math.log(1000,10) //logaritimo
math.log(32,2) 
math.log(1000)
math.e //euller
math.pi //Pi

lib datetime
import datetime
dir(datetime) --recursos 
datetime.date.today() //dia 
datetime.date.now() //agora
data = datetime.date(2020,7,10)
data
data.day // dia 
data.month // mes
data.year // ano 

horario = datetime.datetime(2020,7,10, 7, 30, 0)
horario
horario.hour //hora 
horario.minute // minuto
horario.second // segundos


a30
lib random 
import random
random.random() //gerando numeros aleatorios
random.randint(1,10) // gerando numeros inteiros aleatorios
random.randrange(0,10,2) // intervalo range
random.randrange(0,10,3) // range 
x = ['k','d',13,'34-j','x'] // lista
x
random.choice(x) //sortear os elementos de uma lista

lib time 
import time as tm
tm.time() //valor do tempo
antes = tm.time() // tempo atual 
lista = []
for i in range(0,1000):
    lista.append(i)
depois = tm.time()

intervalo = depois - antes // tempo de exec 
print(f'Tempo: {intervalo} 'segundos') 

print('Finalizando')
tm.sleep(2) //esperando o tempo 
print('..')
tm.sleep(2) // esperando o tempo 
print('Ate a proxima')

a31 2310
salva arquivo, pacote util 
colamos as funcoes

def soma(a,b,c):
    somatorio = a+b+b
    return somatorio

def mult(a,b,c):
    produto = a*b*c
    return produto

def isPalindromo(string)
    if string == string[::-1]:
        return True
    else:
        return False

em modulos 
carregamos no jupyter ou no colab
carregamos o arq e teremos o arquivo no diretorio
depois importamos o util

import util as ut //que é o modulo que criamos
ut.soma(1,2,3) // modulo import e func soma
ut.mult(3,2,2) // mod e func mult 
ut.isPalindromo('abc') // mod e func isPalindromo
ut.isPalindromo('abccba')
t = 'abccba'
t[::-1] // slice de traz p frente 
t1 = 'abc'
t1[::-1] 

//incluimos essa funcao no util e temos que importar novamente
def divisao(a,b): 
    return a/b

temos que reinicializar o ambiente para importar novamente

a34-210121

Tratamento de erros e exceções
NameError: variável nao foi definida
- TypeError: tipos de dados incompatíveis
- RuntimeError: erro de execução
- SyntaxError: sintaxe digitada é inválida e não reconhecida pelo interpretador
- ZeroDivisionError: divisão por zero
- IndexError: índice está fora da coleção


c = [1,2,3,4,5]
c[5] # Index error

Tratamento de erros 
try:
    n = int(input('Digite um numero inteito:'))
    colocar letrar #ValueError
except:
    print('Valor inválido')
else:
    print(f'Valor digitado é {n}')

while True:
    try:
        n = int(input('Digite um numero inteito:'))
        colocar letrar #ValueError
    except:
        print('Valor inválido')
    else:
        print(f'Valor digitado é {n}')

while True:
    try:
        n = int(input('Digite um numero inteito:'))
        colocar letrar #ValueError
    except:
        print('Valor inválido')
    else:
        print(f'Valor digitado é {n}')
        break 

while True:
    try:
        p = int(input('Digite um numero inteiro:'))
        colocar letrar #ValueError
    except ValueError:
        print('Valor inválido')
    except KeyboardInterrupt:
        print('Usuário interrompeu a execução')
        break
    else:
        print(f'Valor digitado é {p}')
        break 


a36-210121

lista = []
try:
    lista.append(float(input('Digite o primeiro valor: ')))
    lista.append(float(input('Digite o primeiro valor: ')))
    soma = lista[0] / lista[1]
except ValueError:
    print('Voce digitou um caracter')
except ZeroDivisionError:
    print('Voce digitou zero, impossivel fazer uma divisão por zero')
except IndexError:
    print('A posicão da lista não pode ser dividida')
except KeyboardInterrupt:
    print('O usuário interrompeu a execução')


a37-220121
Manipulação de arquivos

subir o arquivo para o diretorio
with open('caminho_diretorio.txt') as tx:
    for linha in tx:
        print(linha)

with open('caminho_diretorio.txt') as tx:
    r = tex.readlines()
    
print(r)

with open('texto2.txt','w') as texto:
    texto.write('olá a todos')

with open('caminhododiretorio/texto2.txt','r') as texto2:
    for linha in texto2:
        print(linha)

a40-260121
Regular Expressions
Busca sofisticada por padroes 
procurar todas as palavras que começam com letra maiuscula, ou que começam com letra maiuscula e terminam com letra minuscula 
que começam com 'a' e terminam com 'e'
procurar emails, numero de telefone, ceps, etc
padroes de busca são ilimitados 

Tres funcoes 
SEARCH - encontrar ou pesquisar as posicoes de padroes dentro de uma string, se estes estiverem presentes 
MATCH - se o começo de uma string é igual a um determinado padrão(metodo match)
FINDALL - encontrar todas as substrings em uma string que correspondam a um padrão

.-qualquer caractere (exceto linha nova)
\w - qualquer caractere alfanumerico
\W - qualquer caractere não-alfanumerico
\d - qualquer caractere que seja um digito(0-9)
\D - qualquer caractere não digito
\s - espaço em branco
^ - começa com 
$ - termina com 
'\' - usado antes de metacaracteres para especificar seu significado literal 

Quantificadores 
permitem determinar como e quantas vezes os metacaracteres aparecem 

[] - opcional entre os que estão dentro dos colchetes 
() - captura grupos de caracteres 
* - de zero a mais vezes 
? - zero ou uma vez 
+ - uma ou mais vezes 
{m,n} - de m a n vezes 
| - ou 

.gabrielcosta@hotmail.com
.felipearruda@gmail.com
.joaosilva@yahoo.com.br

a41-260121

Function search 
import re 
frase = 'Olá, meu numero de telefone é (42)0000-0000'
re.search('\(\d{2}\)\d{4,5}-\d{4}', frase)


frase = 'A placa de carro que eu anotei durante o acidente foi frt-1998'
re.search('[A-Za-z]{3}-\d{4}', frase)

email = 'Entre em contato, meu email é teste@teste.com'
re.search('\w+@\w+\.com',email)

Function match

frase = 'A placa de carro que eu anotei durante o acidente foi FRT-1998'
print(re.match('[A-Za-z]{3}-\d{4}', frase))

frase2 = 'FRT-1998 é a placa do carro'
print(re.match('[A-Za-z]{3}-\d{4}', frase2))


Function findall
frase3 = 'Meu número de telefone atual é (42)0000-0000. O número (56)1111-1111 é o antigo'
re.search('\(\d{2}\)\d{4,5}-\d{4}', frase3)

emails = '''Nome: Teste 1 
emails: teste1@teste.com
Nome: Teste 2 
email: teste2@teste.com
Nome: Teste 3 
email: teste3@teste.com.br

re.findall('\w+@\w+\.\w*', emails)

a45-280121

OO
class Triangulo:
    def __init__(self, lado1, lado2, lado3, base, altura):
        self.lado1 = lado1
        self.lado2 = lado2
        self.lado3 = lado3
        self.base = base
        self.altura = altura

    def area(self):
        return (self.base * self.altura) / 2

    def tipo(self)
        if self.lado1 > self.lado2 + self.lado3:
            return 'não é um triangulo'
        elif self.lado2 == self.lado2 or self.lado1 == self.lado3 or self.lado1 == self.lado2:
            return 'triangulo isóceles'
        else:
            return 'outro tipo de triangulo'

t1 = Tringulo(2, 1, 3, 4, 3)
print(t1.lado1,t1.lado2, t1.lado3,t1.base, t1.altura)
t1.area()
t1.tipo()

t2 = Triangulo(8,8,8,16,9)
print(t2.lado1,t2.lado2,t2.lado3,t2.base, t2.altura)
t2.area()
t2.tipo()

a47-030221

class Studant: 
    def __init__(self,name,grade1, grade2):
        self.name = name 
        self.grade1 = grade1
        self.grade2 = grade2
        self.mean = 0

    def mean_calculate(self):
        self.mean = (self.grade1 + self.grade2) / 2
        return self.mean
   
    def data_show(self):
        print('Name: ',self.name)
        print('Grade 1: ',self.grade1)
        print('Grade 2: ',self.grade2)
        print('Mean: ', self.mean)

    def result(self):
        if self.mean >= 6.0:
            print('aprovado')
        else:
            print('reprovado')

a48-030221

#11 passos
function1
def soma1(n):
    soma = 0 
    for i in range(n + 1):
        soma += i 
    return soma 

%timeit soma1(10) #gera time de exec

#3 passos 
function2
def soma2(n):
    return (n * (n + 1)) / 2

%timeit soma2(10)

a complexidade do algoritmo aumenta com as entradas
comparativos entre os algoritmos, desempenho de cada uma

função1 temos uma notação O(n) # muda de acordo com os inputs que recebe 
função2 temos uma notação O(3) # não muda de acordo com os inputs que recebe
